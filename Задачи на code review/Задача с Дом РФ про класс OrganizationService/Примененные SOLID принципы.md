
# SOLID для `OrganizationService` (коротко и по делу)

## S — Single Responsibility Principle (SRP, принцип единственной ответственности)

**Идея (перевод):** Класс должен иметь одну причину для изменения — одну ответственность.

**Как применено:**

* `OrganizationService` стал **оркестратором** операций высокого уровня: получение/установка логотипа, вычисления по проектам.
* Инфраструктурные детали (файловое хранилище, уведомления, внешний API, БД) вынесены за пределы логики: в конструктор инжектируются интерфейсы `IFileStorageService`, `INotificationService`, `IProjectExternalApi`, `AppDbContext`.
* Каждая операция (`GetOrganizationLogoAsync`, `SetOrganizationLogoAsync`, `CalculateAsync`) решает свою задачу, не смешивая разные уровни (нет прямого управления каналами Kafka/внутренней логикой файлового хранилища).

**Потенциальный нюанс:**
`OrganizationService` всё ещё агрегирует несколько бизнес-операций (I/O + доменная логика проверки сущности + нотификация). Для большинства middle+ задач это ок (application/service layer). Если методики станут сложнее — можно выделять отдельные *use-case* классы (например `OrganizationLogoManager`, `OrganizationCalculator`) → ещё более строго SRP.

**Как сказать на собесе:**
«Я разнес ответственность: сервис оркестрирует операции, а детали доступа к файлам/уведомлениям/внешнему API реализуются через интерфейсы. Если логика вырастет — вынесу конкретные use-case в отдельные классы.»

---

## O — Open/Closed Principle (OCP, принцип открытости/закрытости)

**Идея (перевод):** Модуль должен быть открыт для расширения и закрыт для модификации.

**Как применено:**

* Через интерфейсы (`IFileStorageService`, `IProjectExternalApi`, `INotificationService`) можно **добавлять новые реализации** (например, менять провайдера файлового хранилища или внешний API) без правок `OrganizationService`.
* Поведение метода можно расширить (например, добавить кэширование или логирование) через декораторы/фильтры или внедрение новых реализаций — без изменения кода сервиса.

**Как сказать на собесе:**
«Service не ломается при добавлении новых провайдеров; чтобы изменить поставщика файлов, правок в сервисе не требуется — достаточно подменить реализацию интерфейса.»

---

## L — Liskov Substitution Principle (LSP, принцип подстановки Барбары Лисков)

**Идея (перевод):** Объекты-наследники (или реализации интерфейсов) должны быть взаимозаменяемы без нарушения правильной работы программы.

**Как применено:**

* `OrganizationService` использует абстракции (интерфейсы). Любая реализация `IFileStorageService`/`INotificationService`/`IProjectExternalApi` должна:

  * соответствовать контракту (методы возвращают ожидаемые типы/поведение),
  * не менять семантику (например, `GetLogoByIdAsync` должен возвращать `Stream` или `null` и не бросать неожиданных исключений без документации).
* При написании конкретных реализаций важно соблюдать ожидаемую семантику (например, не делать `GetLogoByIdAsync` блокирующим или не возвращающим `Stream`).

**Практический совет:**
В реализации интерфейсов договариваться о поведении (что возвращается при not found — `null` или бросается исключение). Это уменьшит вероятность нарушения LSP.

**Как сказать на собесе:**
«Полагаюсь на контракты интерфейсов — реализации обязаны сохранять контракт (например, возвращать null при отсутствующем ресурсe), чтобы сервис мог их подставлять без изменений.»

---

## I — Interface Segregation Principle (ISP, принцип разделения интерфейсов)

**Идея (перевод):** Лучше много узкоспециализированных интерфейсов, чем один универсальный «тяжёлый».

**Как применено:**

* Интерфейсы небольшие и специализированные:

  * `IFileStorageService` — только операции с файлами;
  * `INotificationService` — только уведомления;
  * `IProjectExternalApi` — только получение проектов.
* Это позволяет реализовать только то, что нужно конкретной реализации (нет лишних методов), упрощает мокинг в тестах и уменьшает связанность.

**Как сказать на собесе:**
«Я разделил интерфейсы по ответственности: каждый делает одну вещь — тестировать и подменять их просто.»

---

## D — Dependency Inversion Principle (DIP, принцип инверсии зависимостей)

**Идея (перевод):** Модули верхнего уровня не должны зависеть от модулей низкого уровня; оба должны зависеть от абстракций. Абстракции не должны зависеть от деталей; детали должны зависеть от абстракций.

**Как применено:**

* `OrganizationService` зависит от абстракций (`IFileStorageService`, `INotificationService`, `IProjectExternalApi`) вместо конкретных классов (`FileStorageService` и т.д.).
* Благодаря этому можно подставить фейки/моки в тестах, сменить реализацию на новую библиотеку без правок сервиса, а также внедрять паттерны (retry, caching) через обёртки/декораторы.

**Как сказать на собесе:**
«Сервис зависит от интерфейсов, а не от конкретных реализаций — это упрощает тестирование и замену компонентов».

---

# Короткая таблица — SOLID и `OrganizationService`

| Принцип                                                      |                                                                                                                                                 Применение в коде | Короткая фраза для собеса                                                                 |
| ------------------------------------------------------------ | ----------------------------------------------------------------------------------------------------------------------------------------------------------------: | ----------------------------------------------------------------------------------------- |
| **S** — Single Responsibility (Единственная ответственность) | `OrganizationService` — оркестратор; операции разделены (`GetOrganizationLogoAsync`, `SetOrganizationLogoAsync`, `CalculateAsync`) и инфраструктура инжектирована | «Каждый класс — за своё: домен от инфраструктуры»                                         |
| **O** — Open/Closed (Открыт/Закрыт)                          |                                                                                      Добавление новых хранилищ/провайдеров через интерфейсы без изменений сервиса | «Можно расширять через новые реализации, не меняя сервис»                                 |
| **L** — Liskov Substitution (Подстановка Лисков)             |                                                       Реализации интерфейсов должны сохранять контракт (`null`/исключение при «не найдено», асинхронность и т.д.) | «Реализации взаимозаменяемы — сервис работает корректно с любой реализацией»              |
| **I** — Interface Segregation (Разделение интерфейсов)       |                                                                            Узкие интерфейсы: `IFileStorageService`, `INotificationService`, `IProjectExternalApi` | «Небольшие интерфейсы — легче реализовать и мокать в тестах»                              |
| **D** — Dependency Inversion (Инверсия зависимостей)         |                                                                                               Зависимость от абстракций (интерфейсов), инъекция через конструктор | «Сервис зависит от интерфейсов, не от конкретных классов — легко подменять и тестировать» |

---

## Несколько финальных замечаний (что ещё можно сказать/улучшить)

* **SRP trade-off:** если `OrganizationService` начнёт расти (много разных use-case), стоит выделить отдельные классы для каждого use-case (`OrganizationLogoManager`, `OrganizationCalculator`) — это покажет продвинутость на собесе.
* **Тип для денег:** `long` в `ProjectDto.Cost` — лучше обсуждать использование `decimal` для финансов.
* **Outbox/надёжность нотификаций:** если уведомления критичны — можно использовать Outbox pattern так же, как в FlightService.
* **Контракты интерфейсов:** обязательно обсудить, что делать при «не найдено» — `null` или исключение. Это уменьшит риск LSP-проблем.

---

