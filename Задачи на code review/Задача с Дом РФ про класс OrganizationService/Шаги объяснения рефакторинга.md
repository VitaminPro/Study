Ключевые идеи, которые я применяю в рефакторинге:

* убрать загрузку всей таблицы (`ToList()` + `Where(...).First()`), делать целевой запрос к БД (`SingleOrDefaultAsync` / `FindAsync`);
* вернуть асинхронность на уровне API (`Task` + `async/await`) и поддерживать `CancellationToken`;
* внедрять зависимости через интерфейсы (тестируемость, DIP);
* корректно работать с `Stream` (закрывать/Dispoe, использовать async методы);
* правильно ждать `SaveChangesAsync` и логировать ошибки;
* исправить бизнес-логику фильтрации в `Calculate`;
* учитывать деньги/суммы (тип `long` в оригинале — оговорюсь в комментариях).

---

## Быстрый разбор проблем в оригинале

1. `ToList()` загружает всю таблицу `Organizations` в память — плохо по производительности и в продакшне недопустимо.
2. Поиск `Where(...).First()` — лучше `SingleOrDefaultAsync` / `FindAsync` и обработка случая «не найдено».
3. Методы синхронные; внешние операции (файлы, внешнее API, БД) — должны быть асинхронными.
4. Не используется `CancellationToken`.
5. `Stream` читается синхронно, `MemoryStream` не освобождается явно.
6. `SaveChangesAsync(default)` вызывается, но не `await` — это ошибка: изменения могут не сохраниться до вызова Notify.
7. Логики обработки ошибок и логирования нет.
8. В `Calculate` логика фильтрации `if (project.CompleteDate > start || project.CompleteDate < finished)` — неверна (и переменные start/finished могут быть null).

---


## Объяснение внесённых изменений (коротко, чтобы сказать на собеседовании)

1. **Асинхронность и отмена**

   * Сделал асинхронные методы `GetOrganizationLogoAsync`, `SetOrganizationLogoAsync`, `CalculateAsync` и прокинул `CancellationToken`.
   * Почему: операции с файлом, внешним API и БД могут быть долгими — нужно не блокировать поток и иметь возможность отмены.

2. **Только целевые запросы к БД**

   * Убрал `ToList()` → делаем `SingleOrDefaultAsync` / `AsNoTracking()`.
   * Почему: не загружаем в память всю таблицу — это масштабируемо и эффективно.

3. **Интерфейсы для инфраструктуры**

   * `IFileStorageService`, `INotificationService`, `IProjectExternalApi` вместо конкретных реализаций.
   * Почему: тестируемость (моки) и принцип DIP.

4. **Правильная работа со Stream**

   * Использую `await using` и `CopyToAsync` — чтобы не утекали дескрипторы, правильно освобождать ресурсы.

5. **Await SaveChangesAsync**

   * Обязательно `await` — иначе уведомление могло уйти до того, как данные сохранены.

6. **Коррекция логики фильтрации**

   * Исправил условие на `CompleteDate >= start && CompleteDate <= finished`.
   * Обработал null-границы.

7. **Логирование и явное поведение при "не найдено"**

   * Логирую предупреждения и бросаю исключение / возвращаю `null`, в зависимости от метода.
   * Это прозрачнее для поддержки.

8. **Про типы денег**

   * В оригинале `long` — это не лучшая практика для денег. На собесе можно объяснить, что для финансов лучше `decimal` (поясни причину, если захотят вдаваться в детали).

---

## Как объяснить это на собеседовании (шаблон ответов, шаг за шагом)

1. **Коротко о проблемах:**

   > В исходном коде была загрузка всей таблицы `Organizations` (`ToList()`), синхронные операции работы с файлами и БД, `SaveChangesAsync` не ожидался и не было поддержки отмены. Всё это может привести к OOM и гонкам/недосохранению в реальной нагрузке.

2. **Что сделал:**

   > Я сделал методы асинхронными и добавил `CancellationToken`, убрал `ToList()` и делаю целевые запросы в БД (`SingleOrDefaultAsync` / `AsNoTracking()`), ввёл интерфейсы для зависимостей чтобы можно было мокать, правильно работаю со `Stream` и гарантирую, что `SaveChangesAsync` завершится до уведомления.

3. **Почему это важно:**

   > Такой код масштабируется, его легче тестировать, он корректно обрабатывает ошибки/отмены и не теряет данные при длительных операциях.

4. **Trade-offs / дальнейшие улучшения (что можно ещё сделать):**

   * Если внешнее API возвращает большие списки, лучше позволять ему фильтровать по датам (передавать from/to в `GetProjectsAsync`) и/или поддержать пагинацию/стриминг.
   * Для уведомлений можно использовать Outbox (если нужна надёжность доставки при сбоях).
   * Для вычислений стоимости лучше использовать `decimal` и/или агрегировать на стороне источника данных (если возможно).

5. **Короткая финальная фраза:**

   > Такие изменения делают сервис безопасным для продакшена: меньше памяти, предсказуемая работа при нагрузке и простая тестируемость — то, что ожидают от middle+ инженера.

---

