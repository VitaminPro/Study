# Оптимизация PostgreSQL для .NET-разработчика - Тест из 40 вопросов

## 1. Анализ планов выполнения

EXPLAIN ANALYZE предоставляет детальную информацию о том, как PostgreSQL выполняет запрос, включая фактическое время выполнения, количество обработанных строк и использование индексов. Понимание планов выполнения критично для оптимизации производительности.

**Вопрос:** Какая метрика в EXPLAIN ANALYZE указывает на то, что индекс используется неэффективно?

1. Высокое значение cost
✅ 2. Высокое значение rows removed by filter
3. Низкое значение actual time
4. Большое количество loops

## 2. Статистика и планировщик

PostgreSQL собирает статистику о распределении данных в таблицах для принятия решений планировщиком. Устаревшая статистика может привести к неоптимальным планам выполнения запросов.

**Вопрос:** Какая команда обновляет статистику для планировщика запросов?

1. UPDATE STATISTICS
2. REFRESH STATS
✅ 3. ANALYZE
4. RECOMPUTE STATS

## 3. Индексы по выражениям

Функциональные индексы позволяют индексировать результат выражения или функции, что особенно полезно для запросов, использующих функции в WHERE условиях.

**Вопрос:** Как создать индекс для ускорения запросов вида `WHERE LOWER(name) = 'john'`?

1. `CREATE INDEX ON users (name)`
✅ 2. `CREATE INDEX ON users (LOWER(name))`
3. `CREATE FUNCTIONAL INDEX ON users (name)`
4. `CREATE INDEX ON users USING (LOWER(name))`

## 4. Partial индексы

Частичные индексы индексируют только строки, удовлетворяющие определенному условию, что экономит место и улучшает производительность для специфических запросов.

**Вопрос:** Какой синтаксис создает индекс только для активных пользователей?

1. `CREATE INDEX ON users (id) FILTER (status = 'active')`
✅ 2. `CREATE INDEX ON users (id) WHERE status = 'active'`
3. `CREATE INDEX ON users (id) IF status = 'active'`
4. `CREATE PARTIAL INDEX ON users (id) WITH status = 'active'`

## 5. Оптимизация соединений (JOIN)

Порядок таблиц в JOIN и тип соединения существенно влияют на производительность. PostgreSQL автоматически оптимизирует порядок JOIN, но понимание принципов помогает писать лучшие запросы.

**Вопрос:** Какой фактор наиболее влияет на производительность JOIN операций?

1. Количество столбцов в SELECT
2. Длина имен таблиц
✅ 3. Наличие индексов на столбцах соединения
4. Порядок таблиц в запросе

## 6. Настройка work_mem

Параметр work_mem определяет количество памяти для операций сортировки, hash join и других операций. Недостаток памяти приводит к использованию диска, что замедляет выполнение.

**Вопрос:** Что происходит при превышении work_mem во время выполнения запроса?

1. Запрос отменяется с ошибкой
2. Скорость выполнения увеличивается
✅ 3. Операция переходит на использование диска
4. Автоматически увеличивается work_mem

## 7. Оптимизация GROUP BY

При группировке больших наборов данных важно использовать эффективные алгоритмы. HashAggregate быстрее для небольших групп, GroupAggregate - для отсортированных данных.

**Вопрос:** Какой метод группировки эффективнее для большого количества уникальных групп?

✅ 1. HashAggregate
2. GroupAggregate  
3. SortAggregate
4. IndexAggregate

## 8. Оптимизация подзапросов

EXISTS обычно работает быстрее IN для подзапросов, особенно когда подзапрос возвращает много строк, так как EXISTS прекращает выполнение при первом совпадении.

**Вопрос:** Какая конструкция обычно работает быстрее для проверки существования связанных записей?

✅ 1. EXISTS (SELECT 1 FROM ...)
2. IN (SELECT id FROM ...)
3. COUNT(*) > 0
4. JOIN с DISTINCT

## 9. Мониторинг активности

pg_stat_activity предоставляет информацию о текущих запросах и их состоянии, что помогает выявлять проблемы производительности в реальном времени.

**Вопрос:** Какое представление показывает текущие выполняющиеся запросы?

1. pg_active_queries
2. pg_current_queries
✅ 3. pg_stat_activity
4. pg_running_queries

## 10. Кеширование в PostgreSQL

PostgreSQL использует shared_buffers для кеширования страниц данных в памяти. Правильная настройка этого параметра критична для производительности.

**Вопрос:** Какой процент от общей памяти системы обычно рекомендуется для shared_buffers?

1. 10-15%
✅ 2. 25-30%
3. 50-60%
4. 80-90%

## 11. Оптимизация LIMIT и OFFSET

При использовании OFFSET для пагинации производительность деградирует с увеличением смещения, так как PostgreSQL должен обработать все пропускаемые строки.

**Вопрос:** Почему OFFSET становится медленным при больших значениях?

1. Индексы не работают с OFFSET
✅ 2. PostgreSQL должен обработать все пропускаемые строки
3. OFFSET блокирует всю таблицу
4. Память заканчивается при больших OFFSET

## 12. Составные индексы и селективность

Порядок столбцов в составном индексе должен соответствовать селективности - более селективные столбцы должны идти первыми для максимальной эффективности.

**Вопрос:** Как правильно упорядочить столбцы в составном индексе?

1. По алфавиту
2. По размеру данных
✅ 3. По селективности (более селективные первыми)
4. По частоте использования в WHERE

## 13. Autovacuum настройка

Autovacuum автоматически очищает устаревшие версии строк и обновляет статистику. Правильная настройка autovacuum критична для поддержания производительности.

**Вопрос:** Какой параметр контролирует частоту запуска autovacuum?

1. autovacuum_frequency
2. vacuum_interval
✅ 3. autovacuum_naptime
4. auto_vacuum_delay

## 14. Параллельные запросы

PostgreSQL поддерживает параллельное выполнение запросов для операций сканирования, соединения и агрегации на многоядерных системах.

**Вопрос:** Какой параметр контролирует максимальное количество worker процессов для параллельных запросов?

1. parallel_workers
✅ 2. max_parallel_workers_per_gather
3. query_parallelism
4. parallel_degree

## 15. Оптимизация INSERT операций

Массовые вставки можно существенно ускорить, используя COPY, отключая автокоммит или группируя операции в транзакции.

**Вопрос:** Какой способ наиболее эффективен для массовой вставки данных?

1. Множественные INSERT в цикле
2. INSERT с множественными VALUES
✅ 3. COPY FROM
4. Prepared statements

## 16. Блокировки и deadlock

Понимание уровней блокировок помогает избегать конфликтов и взаимоблокировок. pg_locks показывает текущие блокировки в системе.

**Вопрос:** Какое представление показывает информацию о текущих блокировках?

1. pg_blocking
2. pg_lock_info
✅ 3. pg_locks
4. pg_wait_events

## 17. Checkpoint оптимизация

Checkpoint записывает dirty pages на диск и может вызывать временные задержки. Настройка checkpoint_segments и checkpoint_completion_target помогает сгладить нагрузку.

**Вопрос:** Что такое checkpoint в PostgreSQL?

1. Точка сохранения транзакции
✅ 2. Процесс записи измененных страниц на диск
3. Проверка целостности данных
4. Создание резервной копии

## 18. Connection pooling в .NET

Пул соединений в Npgsql управляет подключениями к базе данных, переиспользуя существующие соединения для уменьшения накладных расходов.

**Вопрос:** Какой параметр в Npgsql контролирует время жизни соединения в пуле?

1. Connection Lifetime
2. Pool Timeout
✅ 3. Connection Idle Lifetime
4. Max Connection Age

## 19. Prepared statements

Подготовленные запросы компилируются один раз и могут выполняться многократно с разными параметрами, что экономит время на парсинг и планирование.

**Вопрос:** Когда Npgsql автоматически использует prepared statements?

1. Всегда
2. Никогда
✅ 3. После пятого выполнения одинакового запроса
4. Только для SELECT запросов

## 20. Мониторинг медленных запросов

log_min_duration_statement позволяет логировать запросы, выполняющиеся дольше указанного времени, что помогает выявлять проблемы производительности.

**Вопрос:** Как настроить логирование запросов, выполняющихся дольше 1 секунды?

1. `log_slow_queries = 1000`
2. `slow_query_threshold = 1s`
✅ 3. `log_min_duration_statement = 1000`
4. `query_timeout = 1000`

## 21. Оптимизация LIKE запросов

Для эффективной работы LIKE с префиксным поиском нужны специальные индексы. Полнотекстовый поиск более эффективен для сложных паттернов.

**Вопрос:** Какой тип индекса эффективен для запросов `LIKE 'prefix%'`?

✅ 1. B-tree индекс
2. Hash индекс
3. GIN индекс
4. BRIN индекс

## 22. Партиционирование для производительности

Партиционирование разделяет большие таблицы на более мелкие части, что улучшает производительность запросов, затрагивающих только часть данных.

**Вопрос:** Какое главное преимущество партиционирования для производительности?

1. Уменьшение размера индексов
✅ 2. Исключение партиций из планов выполнения (partition pruning)
3. Автоматическая параллелизация запросов
4. Сжатие данных

## 23. Материализованные представления

Материализованные представления хранят результат запроса физически и могут значительно ускорить сложные аналитические запросы.

**Вопрос:** Когда следует использовать материализованные представления?

1. Для всех представлений
2. Только для простых запросов
✅ 3. Для сложных, ресурсоемких запросов с нечастым обновлением данных
4. Для транзакционных операций

## 24. Оптимизация сортировки

Операции сортировки потребляют много ресурсов. Использование индексов может избежать необходимости сортировки в памяти.

**Вопрос:** Как избежать операции сортировки в запросе с ORDER BY?

1. Увеличить work_mem
✅ 2. Создать индекс по столбцам сортировки
3. Использовать LIMIT
4. Добавить больше RAM

## 25. Кластеризация таблиц

CLUSTER физически переупорядочивает строки таблицы согласно индексу, что может улучшить производительность range-запросов.

**Вопрос:** Что делает команда CLUSTER?

1. Создает кластер баз данных
✅ 2. Физически переупорядочивает строки таблицы по индексу
3. Группирует связанные таблицы
4. Создает индекс-кластер

## 26. Настройка effective_cache_size

effective_cache_size сообщает планировщику об объеме доступной операционной системе памяти для кеширования файлов.

**Вопрос:** На что влияет параметр effective_cache_size?

1. Размер shared_buffers
2. Скорость выполнения запросов
✅ 3. Решения планировщика о использовании индексов
4. Количество соединений

## 27. Оптимизация WITH RECURSIVE

Рекурсивные запросы могут быть ресурсоемкими. Proper termination conditions и ограничения глубины рекурсии важны для производительности.

**Вопрос:** Какая главная опасность при использовании WITH RECURSIVE?

1. Блокировка таблиц
2. Потеря данных
✅ 3. Бесконечная рекурсия
4. Нарушение целостности

## 28. Hot и Cold данные

Разделение часто используемых (hot) и редко используемых (cold) данных на разные таблицы или партиции улучшает производительность кеширования.

**Вопрос:** Какая стратегия эффективна для работы с архивными данными?

1. Хранить все данные в одной таблице
✅ 2. Партиционировать по времени и выносить старые партиции на медленное хранилище
3. Сжимать старые данные
4. Дублировать данные

## 29. Оптимизация VACUUM

Полный VACUUM блокирует таблицу и может занимать много времени. Настройка параметров autovacuum обычно предпочтительнее.

**Вопрос:** В чем разница между VACUUM и VACUUM FULL?

1. VACUUM FULL быстрее
✅ 2. VACUUM FULL блокирует таблицу и сжимает файл
3. VACUUM FULL только обновляет статистику
4. Никакой разницы нет

## 30. Асинхронные операции в .NET

Использование async/await в .NET приложениях с Npgsql позволяет не блокировать потоки во время ожидания ответа от базы данных.

**Вопрос:** Почему важно использовать асинхронные методы Npgsql в веб-приложениях?

1. Для ускорения запросов
✅ 2. Для освобождения потоков во время ожидания I/O операций
3. Для лучшего кеширования
4. Для автоматической оптимизации

## 31. Анализ lock contention

Высокая конкуренция за блокировки может существенно замедлить приложение. Мониторинг pg_stat_database помогает выявлять проблемы.

**Вопрос:** Какая метрика в pg_stat_database указывает на проблемы с блокировками?

1. tup_returned
2. tup_fetched
✅ 3. conflicts
4. temp_files

## 32. Оптимизация JSON запросов

Для эффективной работы с JSONB данными нужны специальные индексы. GIN индексы поддерживают различные операторы для JSON.

**Вопрос:** Какой оператор в GIN индексе на JSONB поле работает наиболее эффективно?

1. ->
2. ->>
✅ 3. @>
4. ?

## 33. Batch операции

Группировка множественных операций в одну транзакцию или использование batch API уменьшает сетевые накладные расходы.

**Вопрос:** Какой подход эффективнее для выполнения 1000 INSERT операций?

1. 1000 отдельных транзакций
2. 1000 INSERT в одной транзакции без batch
✅ 3. Batch операции в одной транзакции
4. Parallel.ForEach для INSERT

## 34. Мониторинг I/O

pg_stat_bgwriter показывает статистику записи данных фоновыми процессами, что помогает оценить нагрузку на дисковую подсистему.

**Вопрос:** Какая метрика в pg_stat_bgwriter указывает на недостаток shared_buffers?

1. buffers_clean
2. buffers_backend
✅ 3. buffers_alloc
4. buffers_checkpoint

## 35. Оптимизация DISTINCT

DISTINCT может быть ресурсоемкой операцией. Использование GROUP BY или EXISTS иногда более эффективно.

**Вопрос:** Какая альтернатива DISTINCT может быть более эффективной?

1. UNIQUE
2. LIMIT 1
✅ 3. GROUP BY
4. ORDER BY

## 36. Настройка random_page_cost

random_page_cost влияет на решения планировщика о выборе между сканированием индекса и таблицы, особенно важно для SSD.

**Вопрос:** Какое значение random_page_cost рекомендуется для SSD накопителей?

1. 4.0 (по умолчанию)
2. 2.0
✅ 3. 1.1
4. 0.5

## 37. Оптимизация UPDATE операций

UPDATE может быть медленным из-за необходимости обновления индексов. HOT (Heap-Only Tuples) updates избегают обновления индексов.

**Вопрос:** Когда UPDATE может использовать HOT optimization?

1. Всегда
2. Только для больших таблиц
✅ 3. Когда обновляемые столбцы не участвуют в индексах
4. Только в транзакциях

## 38. Оптимизация полнотекстового поиска

Полнотекстовый поиск в PostgreSQL поддерживает различные конфигурации языков и весов, что влияет на релевантность результатов.

**Вопрос:** Какая функция ранжирует результаты полнотекстового поиска?

1. ts_score
2. ts_weight
✅ 3. ts_rank
4. ts_relevance

## 39. Мониторинг размера базы данных

Контроль роста базы данных и отдельных объектов помогает планировать ресурсы и выявлять проблемы.

**Вопрос:** Какая функция возвращает размер таблицы включая индексы?

1. pg_table_size()
2. pg_database_size()
✅ 3. pg_total_relation_size()
4. pg_relation_size()

## 40. Оптимизация соединений приложения

Правильная настройка пула соединений и управление их жизненным циклом критично для производительности приложения.

**Вопрос:** Какая стратегия оптимальна для долгоживущих веб-приложений?

1. Одно соединение на весь процесс
2. Новое соединение для каждого запроса
✅ 3. Пул соединений с правильно настроенными лимитами
4. Максимальное количество соединений
