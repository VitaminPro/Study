### Apache Kafka

1. **Контекст:** На собеседованиях часто спрашивают о базовой архитектуре Kafka. Ключевой элемент этой архитектуры — топик, который для масштабируемости и параллелизма делится на партиции. Понимание того, как сообщения распределяются по этим партициям, является фундаментальным.

   **Вопрос:** Каким образом продюсер Kafka по умолчанию определяет, в какую партицию топика отправить сообщение, если ключ сообщения (`message key`) не указан (равен `null`)?

   **Вариант 1:** Сообщение отправляется во все партиции одновременно.  
   **Вариант 2:** ✅ Сообщение отправляется в партиции по очереди, используя алгоритм Round-robin.  
   **Вариант 3:** Сообщение отправляется в случайную партицию.  
   **Вариант 4:** Сообщение отправляется в первую партицию (партицию 0).

2. **Контекст:** Гарантия порядка обработки сообщений — одна из самых частых тем на интервью. Kafka предоставляет строгие, но ограниченные гарантии, и важно понимать их границы.

   **Вопрос:** Какое утверждение о гарантии порядка сообщений в Kafka является верным?  
   **Вариант 1:** Kafka гарантирует порядок сообщений в рамках всего топика.  
   **Вариант 2:** Kafka гарантирует порядок сообщений между всеми консьюмерами в одной `consumer group`.  
   **Вариант 3:** ✅ Kafka гарантирует строгий порядок сообщений только в пределах одной партиции.  
   **Вариант 4:** Kafka не предоставляет никаких гарантий порядка сообщений.

3. **Контекст:** `Consumer Group` — это основная концепция, позволяющая масштабировать чтение из Kafka. Понимание механизма перебалансировки (`rebalancing`) и его триггеров критически важно для эксплуатации систем в production.

   **Вопрос:** Что из перечисленного **не** вызовет процесс перебалансировки (`rebalancing`) в `consumer group`?  
   **Вариант 1:** Добавление нового экземпляра консьюмера в группу.  
   **Вариант 2:** ✅ Продюсер начал отправлять сообщения со значительно большей скоростью.  
   **Вариант 3:** Экземпляр консьюмера вышел из строя или не отправлял `heartbeat` дольше, чем `session.timeout.ms`.  
   **Вариант 4:** Администратор добавил новые партиции в топик, из которого читает группа.

4. **Контекст:** Отказоустойчивость в Kafka достигается за счет репликации. Понимание роли ZooKeeper (в более старых версиях) или KRaft (в новых) и того, как кластер реагирует на сбои, — это популярный вопрос для оценки знаний архитектуры.

   **Вопрос:** Какова основная роль ZooKeeper в архитектуре Apache Kafka (до версии 3.x, где активно внедряется KRaft)?  
   **Вариант 1:** Хранение самих сообщений.  
   **Вариант 2:** ✅ Координация брокеров, выбор `controller`'а, хранение метаданных о топиках и списках доступа (ACL).  
   **Вариант 3:** Балансировка нагрузки на продюсеров.  
   **Вариант 4:** Управление жизненным циклом консьюмеров.

5. **Контекст:** Настройка `acks` у продюсера напрямую влияет на компромисс между производительностью и надежностью доставки. Это один из самых частых вопросов для проверки понимания гарантий доставки.

   **Вопрос:** Что означает настройка `acks=all` (или `-1`) у продюсера Kafka?  
   **Вариант 1:** Продюсер не ждет никакого подтверждения от брокера и отправляет сообщения максимально быстро.  
   **Вариант 2:** Продюсер ждет подтверждения только от лидера партиции.  
   **Вариант 3:** ✅ Продюсер будет ждать подтверждения от лидера партиции и всех `in-sync` реплик.  
   **Вариант 4:** Продюсер будет ждать подтверждения от всех существующих реплик, даже если они отстали.

6. **Контекст:** Офсет (`offset`) — это "закладка" консьюмера в партиции. Вопрос о том, где и как он хранится, проверяет знание механизмов работы консьюмеров.

   **Вопрос:** Где `consumer group` хранит свои офсеты (`offsets`) по умолчанию в современных версиях Kafka?  
   **Вариант 1:** ✅ В специальном внутреннем топике Kafka с именем `__consumer_offsets`.  
   **Вариант 2:** В ZooKeeper.  
   **Вариант 3:** Локально на диске у каждого экземпляра консьюмера.  
   **Вариант 4:** В оперативной памяти брокера-координатора.

7. **Контекст:** Сравнение Kafka с традиционными брокерами, такими как RabbitMQ, является классикой собеседований. Основное различие кроется в модели потребления сообщений.

   **Вопрос:** Какая модель потребления сообщений используется в Kafka, и чем она отличается от модели в RabbitMQ?  
   **Вариант 1:** Kafka использует push-модель, где брокер "проталкивает" сообщения консьюмерам.  
   **Вариант 2:** ✅ Kafka использует pull-модель, где консьюмер сам запрашивает ("вытягивает") сообщения у брокера.  
   **Вариант 3:** Оба брокера используют одинаковую push-модель.  
   **Вариант 4:** Оба брокера используют одинаковую pull-модель.

8. **Контекст:** `Log compaction` — это важный, но часто упускаемый механизм. Вопросы о нем позволяют оценить глубину знаний кандидата за пределами базового "отправил-получил".

   **Вопрос:** Для какого сценария использования механизм `log compaction` в Kafka подходит лучше всего?  
   **Вариант 1:** Для логов событий, где важна вся история изменений.  
   **Вариант 2:** Для системы очередей задач, где сообщения должны быть удалены после обработки.  
   **Вариант 3:** ✅ Для хранения последнего актуального состояния для каждого ключа (например, текущие координаты пользователя или его профиль).  
   **Вариант 4:** Для архивирования данных за длительный период.

9. **Контекст:** Потеря сообщений — критическая проблема. Вопрос о том, как ее предотвратить, проверяет знание конфигураций как продюсера, так и брокера.

   **Вопрос:** Какая комбинация настроек обеспечивает максимальную гарантию того, что отправленное продюсером сообщение не будет потеряно при сбое одного брокера?  
   **Вариант 1:** `acks=1` и `replication.factor=1`.  
   **Вариант 2:** `acks=0` и `replication.factor=3`.  
   **Вариант 3:** ✅ `acks=all`, `replication.factor=3` и `min.insync.replicas=2`.  
   **Вариант 4:** `acks=1` и `replication.factor=3`.

10. **Контекст:** `ISR` (In-Sync Replicas) — это сердце механизма репликации в Kafka. Понимание этого термина и его значения для отказоустойчивости обязательно для middle+ разработчика.

    **Вопрос:** Что такое список `In-Sync Replicas` (ISR) в Kafka?  
    **Вариант 1:** Список всех консьюмеров, которые в данный момент читают из партиции.  
    **Вариант 2:** Список всех брокеров в кластере.  
    **Вариант 3:** ✅ Список реплик партиции (включая лидера), которые не сильно отстали от лидера.  
    **Вариант 4:** Список партиций, которые были успешно зарезервированы.

---

### RabbitMQ

11. **Контекст:** Основа маршрутизации в RabbitMQ — это `exchange`. Вопросы о типах `exchange` и их поведении являются самыми базовыми и частыми на интервью.

    **Вопрос:** Какой тип `exchange` в RabbitMQ следует использовать, чтобы отправить одно и то же сообщение всем привязанным к нему очередям, игнорируя `routing key`?  
    **Вариант 1:** Direct  
    **Вариант 2:** ✅ Fanout  
    **Вариант 3:** Topic  
    **Вариант 4:** Headers

12. **Контекст:** Гарантия доставки в RabbitMQ строится на механизмах подтверждения (`acknowledgements`). Понимание разницы между автоматическим и ручным подтверждением критично.

    **Вопрос:** Что произойдет с сообщением, если консьюмер, работающий в режиме ручного подтверждения (`autoAck=false`), упадет до того, как отправит `ack` (подтверждение) брокеру?  
    **Вариант 1:** Сообщение будет потеряно.  
    **Вариант 2:** ✅ Сообщение вернется в очередь и будет доставлено другому (или этому же после перезапуска) консьюмеру.  
    **Вариант 3:** Сообщение будет автоматически перемещено в Dead Letter Exchange (DLX).  
    **Вариант 4:** Брокер будет бесконечно ждать подтверждения, заблокировав сообщение.

13. **Контекст:** `Dead Letter Exchange` (DLX) — стандартный паттерн для обработки ошибочных или просроченных сообщений. Умение объяснить, как и почему сообщения туда попадают, — хороший показатель опыта.

    **Вопрос:** Какое из этих событий **не** является причиной попадания сообщения в `Dead Letter Exchange` (при условии, что DLX настроен для очереди)?  
    **Вариант 1:** Сообщение было отклонено консьюмером с параметром `requeue=false`.  
    **Вариант 2:** Истек TTL (Time-To-Live) сообщения.  
    **Вариант 3:** ✅ Консьюмер подтвердил успешную обработку сообщения вызовом `basic.ack`.  
    **Вариант 4:** Очередь достигла своего лимита по длине (`max-length`).

14. **Контекст:** Долговечность (`durability`) — еще одна ключевая тема. Часто путают долговечность очереди и персистентность сообщения. Вопрос нацелен на выявление этого различия.

    **Вопрос:** Чтобы сообщение в RabbitMQ пережило перезагрузку брокера, какие условия должны быть выполнены?  
    **Вариант 1:** Достаточно, чтобы очередь была объявлена как `durable`.  
    **Вариант 2:** Достаточно, чтобы сообщение было отправлено как `persistent`.  
    **Вариант 3:** ✅ И очередь должна быть `durable`, и сообщение должно быть `persistent`.  
    **Вариант 4:** Достаточно, чтобы `exchange` был `durable`.

15. **Контекст:** `Prefetch count` (`QoS`) — важная настройка производительности консьюмера. Неправильная конфигурация может привести к неэффективному использованию ресурсов.

    **Вопрос:** Что контролирует параметр `prefetch count` (`channel.BasicQos`) в RabbitMQ?  
    **Вариант 1:** Максимальное количество сообщений, которое может храниться в очереди.  
    **Вариант 2:** ✅ Максимальное количество сообщений, которое брокер может отправить консьюмеру без получения подтверждения (`ack`).  
    **Вариант 3:** Количество потоков, которое консьюмер использует для обработки сообщений.  
    **Вариант 4:** Приоритет консьюмера при распределении сообщений.

16. **Контекст:** `Binding` — это клей между `exchange` и очередью. Понимание его роли необходимо для построения любой нетривиальной схемы маршрутизации.

    **Вопрос:** Что такое `binding` в терминологии RabbitMQ?  
    **Вариант 1:** Соединение между продюсером и `exchange`.  
    **Вариант 2:** ✅ Правило, которое связывает `exchange` с очередью и определяет, какие сообщения из `exchange` должны попадать в эту очередь.  
    **Вариант 3:** Соединение между консьюмером и очередью.  
    **Вариант 4:** Конфигурация, делающая сообщение персистентным.

17. **Контекст:** `Topic exchange` — самый гибкий тип `exchange`. Умение работать с его шаблонами (`wildcards`) — обязательный навык.

    **Вопрос:** В `topic exchange` отправляется сообщение с `routing key` = `europe.de.berlin.analytics`. Какой `binding key` позволит очереди получать это сообщение?  
    **Вариант 1:** `europe.de.*`  
    **Вариант 2:** `europe.#.analytics`  
    **Вариант 3:** `*.*.berlin.#`  
    **Вариант 4:** ✅ Все перечисленные варианты верны.

18. **Контекст:** Разница между протоколом AMQP и самим брокером RabbitMQ. Этот вопрос проверяет, понимает ли кандидат, что RabbitMQ — это реализация более общего стандарта.

    **Вопрос:** Какой основной протокол реализует RabbitMQ?  
    **Вариант 1:** HTTP  
    **Вариант 2:** MQTT  
    **Вариант 3:** ✅ AMQP (Advanced Message Queuing Protocol)  
    **Вариант 4:** STOMP

19. **Контекст:** `Publisher Confirms` — это механизм обратной связи для продюсера, аналог `acks` в Kafka. Это важный элемент для построения надежных систем.

    **Вопрос:** Для чего используется механизм `Publisher Confirms` в RabbitMQ?  
    **Вариант 1:** Чтобы консьюмер подтвердил продюсеру, что сообщение обработано.  
    **Вариант 2:** Чтобы убедиться, что `routing key` сообщения правильный.  
    **Вариант 3:** ✅ Чтобы продюсер получил подтверждение от брокера, что сообщение было успешно принято и обработано.  
    **Вариант 4:** Чтобы зашифровать сообщение перед отправкой.

20. **Контекст:** Виртуальные хосты (`vhosts`) обеспечивают изоляцию в рамках одного экземпляра RabbitMQ. Это базовый вопрос на знание возможностей multi-tenancy.

    **Вопрос:** Какую задачу решают виртуальные хосты (`vhosts`) в RabbitMQ?  
    **Вариант 1:** Балансировку нагрузки между нодами кластера.  
    **Вариант 2:** ✅ Логическое разделение ресурсов брокера (очередей, `exchanges`, пользователей) для разных приложений.  
    **Вариант 3:** Горизонтальное масштабирование очередей.  
    **Вариант 4:** Репликацию сообщений между дата-центрами.
