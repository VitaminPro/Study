# Git-памятка для .NET backend-разработчика

## Что такое Git?

Git — это система контроля версий. Представьте, что вы пишете курсовую работу и постоянно сохраняете файлы как "Курсовая_v1.docx", "Курсовая_v2.docx", "Курсовая_финальная.docx", "Курсовая_финальная_исправления.docx". Git делает то же самое, но намного умнее — он запоминает все изменения в вашем коде и позволяет легко переключаться между версиями.

## Основные понятия

**Репозиторий (repository)** — папка с вашим проектом, в которой Git отслеживает все изменения.

**Коммит (commit)** — снимок состояния вашего проекта в определенный момент времени. Как сохранение игры.

**Ветка (branch)** — отдельная линия разработки. Основная ветка обычно называется `main` или `master`.

**Удаленный репозиторий (remote)** — версия вашего проекта на сервере (например, на GitHub).

## Настройка Git (делается один раз)

```bash
# Указываем свое имя и email
git config --global user.name "Ваше Имя"
git config --global user.email "ваш@email.com"

# Устанавливаем основную ветку как main (современный стандарт)
git config --global init.defaultBranch main
```

## Создание нового проекта

### Вариант 1: Начинаем локально

```bash
# Создаем папку проекта
mkdir MyWebApi
cd MyWebApi

# Создаем .NET проект
dotnet new webapi

# Инициализируем Git репозиторий
git init

# Добавляем .gitignore для .NET
dotnet new gitignore
```

### Вариант 2: Клонируем существующий проект

```bash
# Скачиваем проект с GitHub/GitLab
git clone https://github.com/username/repository-name.git
cd repository-name
```

## Ежедневная работа с Git

### Проверяем статус

```bash
# Смотрим, какие файлы изменились
git status
```

### Добавляем изменения

```bash
# Добавляем конкретный файл
git add Program.cs

# Добавляем все измененные файлы
git add .

# Добавляем все файлы определенного типа
git add *.cs
```

### Создаем коммит

```bash
# Сохраняем изменения с описанием
git commit -m "Добавил контроллер для пользователей"

# Или более подробное описание
git commit -m "Добавил UserController

- Реализован GET /api/users
- Добавлена валидация входных данных
- Обновлены юнит-тесты"
```

### Смотрим историю

```bash
# История коммитов
git log

# Краткая история (одна строка на коммит)
git log --oneline

# История с графиком веток
git log --graph --oneline
```

## Работа с ветками

### Создание и переключение веток

```bash
# Создаем новую ветку
git branch feature/user-authentication

# Переключаемся на ветку
git checkout feature/user-authentication

# Или создаем и сразу переключаемся (современный способ)
git switch -c feature/user-authentication

# Смотрим все ветки
git branch
```

### Слияние веток

```bash
# Переходим на главную ветку
git switch main

# Сливаем нашу ветку с main
git merge feature/user-authentication

# Удаляем ненужную ветку
git branch -d feature/user-authentication
```

## Работа с удаленным репозиторием

### Подключение к удаленному репозиторию

```bash
# Добавляем ссылку на удаленный репозиторий
git remote add origin https://github.com/username/repository-name.git

# Проверяем подключенные репозитории
git remote -v
```

### Отправка изменений

```bash
# Отправляем изменения в удаленный репозиторий
git push origin main

# При первой отправке новой ветки
git push -u origin feature/new-feature
```

### Получение изменений

```bash
# Скачиваем изменения, но не применяем
git fetch

# Скачиваем и применяем изменения
git pull

# Или более явно:
git pull origin main
```

## Важные файлы для .NET проекта

### .gitignore для .NET

Этот файл говорит Git, какие файлы НЕ нужно отслеживать:

```
# Build results
bin/
obj/
*.dll
*.exe

# Visual Studio
.vs/
*.user
*.suo

# User secrets
appsettings.Development.json
**/appsettings.local.json

# Logs
logs/
*.log

# OS generated files
.DS_Store
Thumbs.db
```

## Полезные команды для ежедневной работы

### Отмена изменений

```bash
# Отменяем изменения в файле (до добавления в staging)
git checkout -- Program.cs

# Или современный способ
git restore Program.cs

# Убираем файл из staging area
git reset HEAD Program.cs
```

### Временное сохранение изменений

```bash
# Прячем текущие изменения
git stash

# Применяем спрятанные изменения
git stash pop

# Смотрим список спрятанных изменений
git stash list
```

### Просмотр изменений

```bash
# Смотрим, что изменилось в файлах
git diff

# Изменения в конкретном файле
git diff Program.cs

# Изменения между коммитами
git diff HEAD~1 HEAD
```

## Типичный рабочий процесс

### 1. Начинаем новую задачу

```bash
git switch main                           # Переходим на главную ветку
git pull origin main                      # Получаем последние изменения с сервера
git switch -c feature/add-logging         # Создаем новую ветку и переключаемся на неё
```

**Почему именно так:** Всегда начинаем с актуальной версии main, чтобы избежать конфликтов позже.

### 2. Разработка с правильными коммитами

```bash
# Добавляем Serilog в проект
dotnet add package Serilog.AspNetCore

git add *.csproj                          # Добавляем только файл проекта
git commit -m "Добавил пакет Serilog"     # Коммитим изменения зависимостей отдельно

# Пишем код настройки логирования...
git add Program.cs                        # Добавляем измененный файл
git status                               # Проверяем, что добавили именно то, что нужно
git commit -m "Настроил Serilog в Program.cs"  # Коммитим логическую единицу

# Создаем middleware для логирования запросов...
git add Middleware/                       # Добавляем новую папку с файлами
git commit -m "Добавил middleware для логирования HTTP запросов"

# Обновляем конфигурацию...  
git add appsettings.json                  # Добавляем конфигурационный файл
git commit -m "Добавил настройки логирования в appsettings.json"
```

**Принцип:** Один коммит = одна логическая задача. Так легче понимать историю и откатывать изменения.

### 3. Отправляем на сервер

```bash
git log --oneline                         # Проверяем наши коммиты перед отправкой
git push -u origin feature/add-logging    # Отправляем ветку на сервер (-u запоминает связь)
```

### 4. После code review

```bash
git switch main                           # Переходим на главную ветку
git pull origin main                      # Получаем актуальные изменения
git merge feature/add-logging             # Сливаем нашу ветку
git push origin main                      # Отправляем обновленную main на сервер
git branch -d feature/add-logging         # Удаляем локальную ветку (она больше не нужна)
git push origin --delete feature/add-logging  # Удаляем ветку на сервере
```

## Исправления и изменения истории

### Исправление последнего коммита

#### Забыли добавить файл в последний коммит:

```bash
git add forgotten-file.cs                 # Добавляем забытый файл
git commit --amend --no-edit              # Дополняем последний коммит без изменения сообщения
```

#### Нужно изменить сообщение последнего коммита:

```bash
git commit --amend -m "Новое правильное сообщение"  # Перезаписываем сообщение последнего коммита
```

#### Нужно изменить и файлы, и сообщение:

```bash
git add new-changes.cs                    # Добавляем новые изменения
git commit --amend -m "Исправленное сообщение с дополнительными изменениями"
```

**⚠️ Внимание:** `--amend` изменяет историю! Используйте только если коммит еще НЕ отправлен на сервер.

### Отмена коммитов

#### Отменить последний коммит, но сохранить изменения:

```bash
git reset --soft HEAD~1                   # Отменяем коммит, файлы остаются в staging area
git status                               # Видим, что изменения готовы к коммиту
# Теперь можем переделать коммит правильно
```

#### Отменить последний коммит и все изменения:

```bash
git reset --hard HEAD~1                   # Полностью удаляем последний коммит и все изменения
```

#### Отменить несколько коммитов:

```bash
git reset --soft HEAD~3                   # Отменяем последние 3 коммита, изменения сохраняем
git reset --hard HEAD~2                   # Полностью удаляем последние 2 коммита
```

### Интерактивное изменение истории (rebase)

#### Изменить последние несколько коммитов:

```bash
git rebase -i HEAD~3                      # Открываем интерактивный редактор для последних 3 коммитов
```

В редакторе вы увидите что-то вроде:
```
pick abc1234 Добавил UserController
pick def5678 Исправил баг в валидации  
pick ghi9012 Обновил тесты

# Commands:
# p, pick = use commit
# r, reword = use commit, but edit the commit message
# e, edit = use commit, but stop for amending
# s, squash = use commit, but meld into previous commit
# d, drop = remove commit
```

**Примеры изменений:**

```bash
# Изменить сообщение коммита:
reword abc1234 Добавил UserController      # Изменит "pick" на "reword"

# Объединить коммиты:
pick abc1234 Добавил UserController
squash def5678 Исправил баг в валидации   # Этот коммит объединится с предыдущим

# Удалить коммит:
drop ghi9012 Обновил тесты                # Этот коммит будет удален из истории
```

#### Изменить порядок коммитов:

```bash
git rebase -i HEAD~3                      # Открываем редактор
# Просто меняем строки местами:
pick def5678 Исправил баг в валидации     # Этот коммит станет первым
pick abc1234 Добавил UserController       # А этот вторым
pick ghi9012 Обновил тесты
```

### Работа с конкретными файлами

#### Отменить изменения в конкретном файле:

```bash
git status                               # Смотрим статус файлов
git restore UserController.cs           # Отменяем изменения в файле (современная команда)
# или старый способ:
git checkout -- UserController.cs       # Отменяем изменения в файле (устаревшая команда)
```

#### Убрать файл из staging area:

```bash
git add .                                # Случайно добавили всё
git status                              # Видим, что добавили лишние файлы
git restore --staged unwanted-file.cs   # Убираем конкретный файл из staging
# или старый способ:
git reset HEAD unwanted-file.cs         # Убираем файл из staging (устаревшая команда)
```

#### Вернуть файл к состоянию из конкретного коммита:

```bash
git log --oneline UserController.cs     # Смотрим историю конкретного файла
git checkout abc1234 -- UserController.cs  # Восстанавливаем файл из коммита abc1234
git add UserController.cs               # Добавляем восстановленный файл
git commit -m "Вернул UserController к рабочей версии"
```

### Сложные сценарии исправлений

#### Изменить коммит в середине истории:

```bash
git rebase -i HEAD~5                     # Открываем последние 5 коммитов
# Находим нужный коммит и меняем "pick" на "edit"
edit abc1234 Нужно исправить этот коммит
pick def5678 Другой коммит
# ... Git остановится на коммите abc1234

# Вносим изменения:
git add fixed-file.cs                    # Добавляем исправления
git commit --amend -m "Исправленное сообщение"  # Дополняем коммит
git rebase --continue                    # Продолжаем rebase
```

#### Разделить один коммит на несколько:

```bash
git rebase -i HEAD~3                     # Открываем редактор
# Меняем "pick" на "edit" для коммита, который нужно разделить
edit abc1234 Большой коммит с множеством изменений

# Git остановится на этом коммите
git reset HEAD~1                         # Отменяем коммит, но сохраняем изменения
git status                              # Видим все изменения как не закоммиченные

# Теперь делаем несколько маленьких коммитов:
git add UserController.cs               # Добавляем первую часть
git commit -m "Добавил UserController"   # Первый коммит

git add UserService.cs                   # Добавляем вторую часть  
git commit -m "Добавил UserService"      # Второй коммит

git add *.cs                            # Добавляем остальное
git commit -m "Обновил тесты"           # Третий коммит

git rebase --continue                    # Завершаем rebase
```

### Работа с stash (временное сохранение)

#### Базовое использование stash:

```bash
# Работаем над функцией, но нужно срочно переключиться на другую задачу
git status                              # Видим незавершенные изменения
git stash push -m "WIP: работаю над аутентификацией"  # Сохраняем изменения с описанием
git switch hotfix/critical-bug          # Переключаемся на другую ветку

# После исправления бага возвращаемся:
git switch feature/authentication        # Возвращаемся к нашей ветке
git stash list                          # Смотрим список сохраненных изменений
git stash pop                           # Применяем последние сохраненные изменения
```

#### Работа с несколькими stash:

```bash
git stash list                          # Смотрим все сохраненные изменения
# stash@{0}: On feature/auth: WIP: работаю над аутентификацией
# stash@{1}: On feature/api: Добавляю новые endpoints

git stash pop stash@{1}                 # Применяем конкретный stash
git stash drop stash@{0}                # Удаляем ненужный stash
git stash clear                         # Очищаем все stash
```

#### Частичное сохранение в stash:

```bash
git stash push -p -m "Только важные изменения"  # Интерактивно выбираем что сохранить
# Git спросит для каждого изменения: сохранить? (y/n/q/a/d/...)
```

### Cherry-pick (применение конкретного коммита)

```bash
git log --oneline                        # Ищем нужный коммит в другой ветке
git switch feature/other-branch          # Переходим на ветку с нужным коммитом  
git log --oneline                        # Находим коммит abc1234
git switch main                          # Возвращаемся на целевую ветку
git cherry-pick abc1234                  # Применяем конкретный коммит
# Если есть конфликты - разрешаем их:
git add .                               # После разрешения конфликтов
git cherry-pick --continue              # Завершаем cherry-pick
```

### Исправление после отправки на сервер

#### Если уже отправили коммит, но нужно исправить:

```bash
# ⚠️ ОПАСНО: изменяет историю на сервере!
git commit --amend -m "Исправленное сообщение"
git push --force-with-lease origin feature/my-branch  # Безопасный force push

# ✅ БЕЗОПАСНО: создаем новый коммит с исправлениями
git add fixed-files.cs
git commit -m "Исправил ошибку в предыдущем коммите"
git push origin feature/my-branch        # Обычный push
```

**Золотое правило:** Никогда не изменяйте историю в общих ветках (main, develop)! Используйте `--force` только в своих feature ветках.

## Советы для хороших коммитов

### Хорошие сообщения коммитов:
- `Добавил валидацию для UserDto`
- `Исправил ошибку с null reference в UserService`
- `Обновил Entity Framework до версии 7.0`

### Плохие сообщения коммитов:
- `fix`
- `работает`
- `изменения`

### Правило: один коммит = одна логическая задача

❌ **Плохо:** в одном коммите добавили новый контроллер, исправили баг и обновили документацию

✅ **Хорошо:** три отдельных коммита для каждой задачи

## Решение проблем

### Если случайно закоммитили что-то лишнее

```bash
# Отменяем последний коммит, но оставляем изменения в файлах
git reset --soft HEAD~1

# Полностью отменяем последний коммит
git reset --hard HEAD~1
```

### Если нужно изменить последний коммит

```bash
# Добавляем забытые изменения к последнему коммиту
git add forgotten-file.cs
git commit --amend -m "Новое сообщение коммита"
```

### Если запутались в конфликтах слияния

```bash
# Прерываем слияние и возвращаемся к исходному состоянию
git merge --abort
```

## Интеграция с Visual Studio

В Visual Studio есть встроенная поддержка Git:

- **Team Explorer** → подключение к репозиториям
- **Git Changes** → просмотр изменений и создание коммитов  
- **Git Repository** → управление ветками и историей
- **Solution Explorer** → иконки показывают статус файлов

## Заключение

Git поначалу может показаться сложным, но эти команды покрывают 90% ежедневной работы. Главное:

1. Делайте коммиты часто и с понятными сообщениями
2. Используйте ветки для новых функций
3. Регулярно синхронизируйтесь с удаленным репозиторием
4. Не бойтесь экспериментировать — Git позволяет откатить почти любые изменения

Со временем эти команды войдут в привычку, и вы будете использовать их автоматически!
